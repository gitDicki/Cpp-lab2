# Лабораторная работа №2 
## Байталоха Сергей, ИТ-1, Вариант 1

---

## Задание 1-3. Заполнение и доступ к элементам. Обратные итераторы.

Дан набор целых чисел с четным количеством элементов. Заполнить вектор V исходными
числами, вывести вначале вторую половину элементов вектора V, а затем первую половину (в
каждой половине порядок элементов не изменять).

## Алгоритм решения:

Создаем переменную int half, в которую записывем половину длины вестора (значение). Далее снасчала выводим вторую половину через цикл for. Начало - начало вектора + half, конец - конец вектора. Вторую половину также выводим через for, у которого начало - начало вектораа, а конец - начало вектора + half. 

## Вывод программы при корректных данных:

Введите количество элементов (чётное число): 6
Введите 6 целых чисел: <br>
1 2 3 4 5 6<br>
Вторая половина: 4 5 6 <br>
Первая половина: 1 2 3 

### Вывод программы при некорректных данных:

Введите количество элементов (чётное число): 5 <br>
Колличество не четное!

Введите количество элементов (чётное число): dbf<br>
Неправильные входные данные.

Введите количество элементов (чётное число): 6<br>
Введите 6 целых чисел:
df
Неправильные входные данные.

## Задание 2-3. Вставка элементов.

Дан список L, количество элементов которого делится на 3. Добавить в конец списка первую
треть его исходных элементов в обратном порядке. Использовать один вызов функции-члена
insert.

## Алгоритм решения:

В переменную it записываем начало спика. Создаем новый список first_third, куда первые три элемента исходного списка в обратном порядке. С помощью функции insert(list.end(), first_third.begin(), first_third.end()) вставляем в конец исходного списка список first_third.

## Вывод программы при корректных данных:

Введите количество элементов (число делится на 3): 6<br>
Введите 6 целых чисел:<br>
1 2 3 4 5 6<br>
Получившийся список: 1 2 3 4 5 6 3 2 1 

Введите количество элементов (число делится на 3): 3  <br>
Введите 3 целых чисел:<br>
1 2 3<br>
Получившийся список: 1 2 3 2 1 

### Вывод программы при некорректных данных:

Введите количество элементов (число делится на 3): 7<br>
Количество не делится на 3!

Введите количество элементов (число делится на 3): 6<br>
Введите 6 целых чисел:<br>
ret 4<br>
Неправильные входные данные.

## Задание 4-5. Итераторы и алгоритмы.

Дан набор символов. Вывести все символы из исходного набора в том же порядке, заменяя
цифровые символы на символ подчеркивания. Использовать алгоритм replace_copy_if.

## Алгоритм решения:

Пользователь вводит строку, которуя записывается в переменную output. Далее с помощью алгоритма replace_copy_if, куда вводим начала строки, конец строки, итератор std::back_inserter(output), который позволяет добавлять элементы в конец контейнера output, лямбда функцию, которая проверяет каждый символ на то, является ли он числоми и символ '_', на который будут заменены числа.

## Вывод программы:

Введите набор символов: у а м в 4 в 6 <br>
Результат: у а м в _ в _


## Задание 5-1. Алгоритмы поиска.

Дан вектор V. Удалить второй из элементов вектора, равных нулю. Если нулевых элементов
меньше двух, то вектор не изменять. Использовать два вызова алгоритма find и функцию-член
erase.

## Алгоритм решения:

С помощью функции find(std::next(first_zero), V.end(), 0) ищем в диапазоне всего вектора первый 0. Если он не является последним элементом, то с позиции первого нуля также ищем второй.Если находим, то удаляем элемент.

## Вывод программы:

1 0 2 0 3 4 0 <br>
1 0 2 3 4 0 

1 0 2 3 4 <br>
1 0 2 3 4 

## Задание 6-1. Базовые модифицирующие алгоритмы. Итераторы вставки.

Даны числа A и B и векторы V1 и V2, каждый из которых содержит не мене<br>е 10 элементов.
Заполнить первые 5 элементов каждого вектора значениями A, а последние 5 — значениями B.
При преобразовании вектора V1 использовать два вызова алгоритма fill, при преобразовании
вектора V2 использовать два вызова алгоритма fill_n.

## Алгоритм решения:

Пользователь вводит два целых числа А и В. Создаем два пустых вектора V1 и V2 размером 10. Используя алгоритм fill(V1.begin(), V1.begin() + 5, A) заполняем вектор V1. V1.begin() - начало вектора,  V1.begin() + 5 - указатель на 5 элемент от начала вектора. Таким образом заполнили первые 5 элементов значением A. fill(V1.end() - 5, V1.end(), B); по такому же принципу заполняем последние 5 элементов вектора значениям B.

Вектор V2 заполняем при помощи fill_n(V2.begin(), 5, A) - здесь указываем начало, до какого элемента дойдет итератор и значенние. Также с конца  fill_n(V2.end() - 5, 5, B).

## Вывод программы при корректных данных:

Введите целое число A: 2<br>
Введите целое число B: 3<br>
Вектор V1: 2 2 2 2 2 3 3 3 3 3 <br>
Вектор V2: 2 2 2 2 2 3 3 3 3 3 

### Вывод программы при некорректных данных:

Введите целое число A: rt <br>
Ошибка! Введите целое число: 3<br>
Введите целое число B: rfv<br>
Ошибка! Введите целое число: -4<br>
Вектор V1: 3 3 3 3 3 -4 -4 -4 -4 -4 <br>
Вектор V2: 3 3 3 3 3 -4 -4 -4 -4 -4

## Задание 7-11.Сортировка и слияние.

Дан дек D, элементами которого являются английские слова. Отсортировать его элементы по
убыванию их длин, а элементы одинаковой длины — в алфавитном порядке. Использовать
единственный вызов алгоритма sort с параметром — функциональным объектом, включающим
как сравнение строк, так и сравнение их длин.

## Алгоритм решения:

Сортируем очередь в алфавитном с момощью алгоритма std::sort(D.begin(), D.end(), Compare()), где указываем начало очереди, ее конец и функциональный объект Comape(). Ф.О. сортирует две строки по колличеству символов.

## Вывод программы при корректных данных:




### Вывод программы при некорректных данных:
